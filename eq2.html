<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Equilibrium Grid</title>

<style>
:root {
  --cell-size: clamp(72px, 22vmin, 120px);
  --gap: clamp(8px, 3vmin, 16px);
  --font-size: clamp(36px, 10vmin, 56px);
  --bg: #0e0e0e;
  --text: #eee;
  --cell-bg: #1e1e1e;
  --cell-hover: #2a2a2a;
  --accent: #44ff44;
  --meter-bg: #1a1a1a;
}

[data-theme="light"] {
  --bg: #f8f9fa;
  --text: #212529;
  --cell-bg: #ffffff;
  --cell-hover: #e9ecef;
  --accent: #198754;
  --meter-bg: #dee2e6;
}

body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  font-family: system-ui, sans-serif;
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: background 0.4s, color 0.4s;
}

.app {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  padding: 16px;
  position: relative;
  width: 100%;
  max-width: 500px;
}

h1 {
  font-weight: 300;
  margin: 0;
  opacity: 0.9;
}

#stats {
  display: flex;
  gap: 2em;
  font-size: 1.2em;
}

#meter {
  width: min(300px, 80vw);
  height: 12px;
  background: var(--meter-bg);
  border-radius: 6px;
  overflow: hidden;
}

#progress {
  height: 100%;
  background: linear-gradient(to right, #ff4444, #ffaa00, var(--accent));
  transition: width 0.3s ease;
  width: 0%;
}

.grid {
  display: grid;
  grid-template-columns: repeat(3, var(--cell-size));
  gap: var(--gap);
  transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  
  animation: gentle-breeze 3s infinite ease-in-out;
}

@keyframes gentle-breeze {
    0%   { transform: rotate(0deg); }
    30%  { transform: rotate(0.9deg); }
    70%  { transform: rotate(-0.9deg); }
    100% { transform: rotate(0deg); }
}

.cell {
  width: var(--cell-size);
  height: var(--cell-size);
  background: var(--cell-bg);
  border-radius: 20%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
  cursor: pointer;
}

.cell:hover { background: var(--cell-hover); }
.cell:active { transform: scale(0.95); }

.cell svg {
  width: 60%;
  height: 60%;
}

.buttons {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  justify-content: center;
}

button {
  background: #222;
  color: #eee;
  border: 1px solid #444;
  padding: 10px 18px;
  border-radius: 10px;
  font-size: 15px;
  cursor: pointer;
  transition: all 0.15s;
}

[data-theme="light"] button {
  background: #e9ecef;
  color: #212529;
  border-color: #ced4da;
}

button:hover { opacity: 0.9; }
button:active { transform: scale(0.97); }

/* –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Ç–µ–º—ã */
.theme-toggle {
  position: absolute;
  top: 16px;
  right: 16px;
  width: 48px;
  height: 48px;
  background: rgba(100,100,100,0.15);
  border-radius: 50%;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  transition: all 0.3s;
  backdrop-filter: blur(4px);
}

[data-theme="light"] .theme-toggle {
  background: rgba(0,0,0,0.08);
}

.theme-toggle:hover {
  transform: scale(1.1);
  background: rgba(120,120,120,0.25);
}

/* Confetti canvas */
#confetti-canvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 100;
}

</style>
</head>

<body data-theme="dark">

<canvas id="confetti-canvas"></canvas>

<div class="app">
  <button class="theme-toggle" id="themeToggle" title="–°–º–µ–Ω–∏—Ç—å —Ç–µ–º—É">‚òÄÔ∏è</button>

  <h1>Equilibrium</h1>
  <div id="stats">
    Level: <span id="level">1</span> | Moves: <span id="moves">0</span>
  </div>
  <div id="meter"><div id="progress"></div></div>
  <div class="grid" id="grid"></div>
  <div class="buttons">
    <button onclick="undo()">‚Ü∂ Undo</button>
    <button onclick="hint()">üí° Hint</button>
    <button onclick="newLevel()">üîÑ New level</button>
  </div>
</div>

<script>
// === –¢–ï–ú–´ ===
function setTheme(theme) {
  document.body.dataset.theme = theme;
  localStorage.setItem('theme', theme);
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è
  const toggle = document.getElementById('themeToggle');
  toggle.textContent = theme === 'light' ? 'üåô' : '‚òÄÔ∏è';
  toggle.title = theme === 'light' ? 'Switch to Dark Mode' : 'Switch to Light Mode';
}

function autoSetTheme() {
  // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –≤—ã–±–∏—Ä–∞–ª —Ç–µ–º—É –≤—Ä—É—á–Ω—É—é ‚Äî –Ω–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º
  if (localStorage.getItem('theme')) return;
  
  const hour = new Date().getHours();
  const isDay = hour >= 7 && hour < 20;
  setTheme(isDay ? 'light' : 'dark');
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ–º—ã
const savedTheme = localStorage.getItem('theme');
if (savedTheme) {
  setTheme(savedTheme);
} else {
  autoSetTheme();
}

// –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å
document.getElementById('themeToggle').addEventListener('click', () => {
  const current = document.body.dataset.theme;
  setTheme(current === 'light' ? 'dark' : 'light');
  // –ü–æ—Å–ª–µ —Ä—É—á–Ω–æ–≥–æ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±–æ—Ä –Ω–∞–≤—Å–µ–≥–¥–∞
  localStorage.setItem('theme', document.body.dataset.theme);
});

// === SVG –ò–ö–û–ù–ö–ò ===
const SVGS = {
  0: `<svg viewBox="0 0 100 100"><defs><radialGradient id="g0"><stop offset="0%" stop-color="#ffffff"/><stop offset="100%" stop-color="#d0d0d0"/></radialGradient></defs><circle cx="50" cy="50" r="45" fill="url(#g0)" stroke="#888" stroke-width="4"/></svg>`,
  1: `<svg viewBox="0 0 100 100"><defs><linearGradient id="g1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#f0f0f0"/><stop offset="100%" stop-color="#b0b0b0"/></linearGradient></defs><rect x="10" y="10" width="80" height="80" rx="12" fill="url(#g1)" stroke="#777" stroke-width="4"/></svg>`,
  2: `<svg viewBox="0 0 100 100"><defs><linearGradient id="g2" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#ffdddd"/><stop offset="100%" stop-color="#cc6666"/></linearGradient></defs><polygon points="50,10 90,80 10,80" fill="url(#g2)" stroke="#a00" stroke-width="4"/></svg>`
};

// === –ê–£–î–ò–û ===
let audioCtx = null;
let isAudioUnlocked = false;

function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function unlockAudio() {
  if (isAudioUnlocked || !audioCtx) return;
  const buffer = audioCtx.createBuffer(1, 1, 22050);
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  source.connect(audioCtx.destination);
  source.start(0);
  if (audioCtx.state === 'suspended') audioCtx.resume();
  isAudioUnlocked = true;
  document.removeEventListener('touchend', unlockAudio);
  document.removeEventListener('click', unlockAudio);
}

function playSound(freq = 440, dur = 0.1, vol = 0.12) {
  if (!audioCtx || audioCtx.state !== 'running') return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.01);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + dur);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + dur + 0.05);
  } catch(e){}
}

document.addEventListener('touchend', unlockAudio, {once:true});
document.addEventListener('click', unlockAudio, {once:true});
window.addEventListener('load', initAudio);

// === –ö–û–ù–§–ï–¢–¢–ò ===
const confettiCanvas = document.getElementById('confetti-canvas');
const ctx = confettiCanvas.getContext('2d');
let confettiParticles = [];
let confettiAnimationId = null;

function resizeConfetti() {
  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
}

window.addEventListener('resize', resizeConfetti);
resizeConfetti();

class Confetti {
  constructor() {
    this.x = Math.random() * confettiCanvas.width;
    this.y = Math.random() * confettiCanvas.height * -0.5 - 50;
    this.size = Math.random() * 8 + 4;
    this.speedY = Math.random() * 5 + 3;
    this.speedX = Math.random() * 4 - 2;
    this.rotation = Math.random() * 360;
    this.rotSpeed = Math.random() * 10 - 5;
    this.color = ['#ff4d4d', '#4dff4d', '#4d4dff', '#ffff4d', '#ff4dff'][Math.floor(Math.random()*5)];
  }
  update() {
    this.y += this.speedY;
    this.x += this.speedX;
    this.rotation += this.rotSpeed;
    if (this.y > confettiCanvas.height + 50) this.y = -50;
  }
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation * Math.PI / 180);
    ctx.fillStyle = this.color;
    ctx.globalAlpha = 0.9;
    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size * 0.4);
    ctx.restore();
  }
}

function launchConfetti(count = 80) {
  for (let i = 0; i < count; i++) {
    confettiParticles.push(new Confetti());
  }
  if (!confettiAnimationId) animateConfetti();
}

function clearConfetti() {
  confettiParticles = [];
  if (confettiAnimationId) {
    cancelAnimationFrame(confettiAnimationId);
    confettiAnimationId = null;
  }
  ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
}

function animateConfetti() {
  ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
  confettiParticles.forEach(p => { p.update(); p.draw(); });
  confettiParticles = confettiParticles.filter(p => p.y < confettiCanvas.height + 100);
  if (confettiParticles.length > 0) {
    confettiAnimationId = requestAnimationFrame(animateConfetti);
  } else {
    confettiAnimationId = null;
  }
}

// === –ò–ì–†–ê ===
const SIZE = 3;
const TYPES = [0,1,2];
let grid = [];
let currentLevel = 0;
let moves = 0;
let history = [];

function neighbors(i) {
  const x = i % SIZE, y = Math.floor(i / SIZE);
  const t = grid[i];
  let dirs = t === 0 ? [[1,0],[-1,0],[0,1],[0,-1]] :
             t === 1 ? [[1,0],[-1,0]] :
                       [[0,1],[0,-1]];
  return dirs.map(([dx,dy]) => [x+dx, y+dy])
    .filter(([nx,ny]) => nx>=0 && ny>=0 && nx<SIZE && ny<SIZE)
    .map(([nx,ny]) => ny*SIZE + nx);
}

function applyMove(i) {
  neighbors(i).forEach(n => grid[n] = (grid[n] + 1) % 3);
}

function isSolved() { return grid.every(v => v === 0); }

function animateRipple(neigh) {
  neigh.forEach((n, idx) => {
    setTimeout(() => {
      const cell = document.querySelector(`[data-idx="${n}"]`);
      if (cell) {
        cell.style.transform = 'scale(1.25)';
        setTimeout(() => cell.style.transform = '', 180);
      }
    }, idx * 35);
  });
}

let gameWon = false;

function clickCell(i) {
  if (gameWon) return;
  history.push(grid.slice());
  if (history.length > 50) history.shift();
  const neigh = neighbors(i);
  animateRipple(neigh);
  applyMove(i);
  moves++;
  playSound(600, 0.08, 0.12);
  render();
  if (isSolved()) {
    gameWon = true;
    playSound(800, 0.25, 0.18);
    playSound(1000, 0.25, 0.18);
    launchConfetti(100);
    setTimeout(() => {
      alert(`üéâ Equilibrium achieved on level ${currentLevel} in ${moves} moves!`);
    }, 300);
  }
}

function getImbalance() {
  return grid.filter(v => v !== 0).length;
}

function updateMeter() {
  const imb = getImbalance();
  document.getElementById('progress').style.width = Math.max(0, (9 - imb) / 9 * 100) + '%';
}

function updateTilt() {
  let torque = 0;
  for (let i = 0; i < 9; i++) {
    const col = i % 3;
    torque += grid[i] * (col - 1);
  }
  const maxDeg = 12;
  const deg = Math.max(-maxDeg, Math.min(maxDeg, torque * -1.5));
  document.getElementById('grid').style.transform = `rotate(${deg}deg)`;
}

function updateStats() {
  document.getElementById('level').textContent = currentLevel;
  document.getElementById('moves').textContent = moves;
}

function render() {
  const g = document.getElementById("grid");
  g.innerHTML = "";
  grid.forEach((v, i) => {
    const d = document.createElement("div");
    d.className = "cell";
    d.innerHTML = SVGS[v];
    d.dataset.idx = i;
    d.onclick = () => clickCell(i);
    g.appendChild(d);
  });
  updateMeter();
  updateTilt();
  updateStats();
}

function newLevel() {
  clearConfetti();
  gameWon = false;
  currentLevel++;
  grid = Array(SIZE * SIZE).fill(0);
  const scrambles = Math.min(15, 2 + currentLevel * 2);
  for (let k = 0; k < scrambles; k++) {
    applyMove(Math.floor(Math.random() * grid.length));
  }
  history = [];
  moves = 0;
  render();
  playSound(500, 0.12, 0.10);
}

function undo() {
  if (history.length) {
    grid = history.pop();
    moves = Math.max(0, moves - 1);
    render();
    playSound(400, 0.10, 0.10);
  }
}

function getNextMove() {
  const start = grid.slice();
  const queue = [{ state: start.slice(), path: [], depth: 0 }];
  const visited = new Set();
  visited.add(start.join('|'));
  while (queue.length) {
    const { state, path, depth } = queue.shift();
    if (state.every(v => v === 0)) {
      return path[0];
    }
    if (depth > 12) continue;
    for (let i = 0; i < 9; i++) {
      const x = i % 3;
      const y = Math.floor(i / 3);
      const t = state[i];
      let dirs = t === 0 ? [[1,0],[-1,0],[0,1],[0,-1]] :
                 t === 1 ? [[1,0],[-1,0]] :
                           [[0,1],[0,-1]];
      const neigh = dirs
        .map(([dx, dy]) => {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && nx < 3 && ny >= 0 && ny < 3) return ny * 3 + nx;
          return -1;
        })
        .filter(n => n >= 0);
      const newState = state.slice();
      neigh.forEach(n => newState[n] = (newState[n] + 1) % 3);
      const key = newState.join('|');
      if (!visited.has(key)) {
        visited.add(key);
        queue.push({ state: newState, path: [...path, i], depth: depth + 1 });
      }
    }
  }
  return -1;
}

function hint() {
  const next = getNextMove();
  if (next >= 0) {
    const cell = document.querySelector(`[data-idx="${next}"]`);
    if (cell) {
      cell.style.boxShadow = '0 0 30px #44ff44';
      cell.style.transition = 'box-shadow 0.3s';
      playSound(700, 0.12, 0.15);
      setTimeout(() => { cell.style.boxShadow = ''; }, 2000);
    }
  } else {
    playSound(300, 0.1, 0.12);
  }
}

// –°—Ç–∞—Ä—Ç –∏–≥—Ä—ã
newLevel();
</script>
</body>
</html>
