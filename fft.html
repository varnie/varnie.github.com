<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Free4talk game</title>
    <link href="fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0; padding: 0; box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        :root {
            --bg: #0d0a12;
            --bg-atmo: rgba(13, 10, 18, 0.98);
            --field: #1a1528;
            --field-alt: #221c35;
            --grid-bg: linear-gradient(135deg, #2a2440, #1e1830);
            --grid-border: rgba(255,255,255,0.08);
            --text: #fff;
            --text-muted: #9ca3af;
            --cloud-opacity: 0.35;
            --shadow-color: rgba(0,0,0,0.5);
            --path-color: rgba(125, 211, 252, 0.08);
            --path-shadow: inset 0 0 5px rgba(125, 211, 252, 0.1);
        }

        body.day-theme {
            --bg: #f0f4f8;
            --bg-atmo: rgba(240, 244, 248, 0.98);
            --field: #e2e8f0;
            --field-alt: #cbd5e1;
            --grid-bg: linear-gradient(135deg, #ffffff, #f1f5f9);
            --grid-border: rgba(0,0,0,0.1);
            --text: #1e293b;
            --text-muted: #64748b;
            --cloud-opacity: 0.6;
            --shadow-color: rgba(0,0,0,0.1);
            --path-color: rgba(56, 189, 248, 0.15);
            --path-shadow: inset 0 0 8px rgba(56, 189, 248, 0.2);
        }

        body {
            font-family: 'Fredoka', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            min-height: 100dvh; /* –î–∏–Ω–∞–º—ñ—á–Ω–∞ –≤–∏—Å–æ—Ç–∞ –¥–ª—è –º–æ–±—ñ–ª—å–Ω–∏—Ö */
            overflow: hidden;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            transition: background 0.5s ease, color 0.5s ease;
            display: flex;
            flex-direction: column;
        }

        .bg-atmosphere {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 0; overflow: hidden; transition: opacity 0.5s;
        }

        .cloud {
            position: absolute; border-radius: 50%; filter: blur(60px);
            opacity: var(--cloud-opacity); animation: float-cloud 20s infinite ease-in-out;
        }
        .cloud:nth-child(1) { width: 500px; height: 300px; background: radial-gradient(ellipse, #ff6b9d, transparent); top: -10%; left: -10%; }
        .cloud:nth-child(2) { width: 400px; height: 250px; background: radial-gradient(ellipse, #7dd3fc, transparent); top: 40%; right: -15%; animation-delay: -5s; }
        .cloud:nth-child(3) { width: 450px; height: 280px; background: radial-gradient(ellipse, #c4b5fd, transparent); bottom: 5%; left: 10%; animation-delay: -12s; }
        
        body.day-theme .cloud { filter: blur(80px); }
        body.day-theme .cloud:nth-child(1) { background: radial-gradient(ellipse, #fde68a, transparent); }
        body.day-theme .cloud:nth-child(2) { background: radial-gradient(ellipse, #93c5fd, transparent); }
        body.day-theme .cloud:nth-child(3) { background: radial-gradient(ellipse, #f0abfc, transparent); }

        @keyframes float-cloud {
            0%, 100% { transform: translateX(0) translateY(0) scale(1) rotate(0deg); }
            50% { transform: translateX(30px) translateY(-20px) scale(1.1) rotate(1deg); }
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed; top: 10px; right: 10px; z-index: 200;
            background: var(--field); border-radius: 30px; padding: 4px;
            display: flex; align-items: center; gap: 4px;
            box-shadow: 0 4px 10px var(--shadow-color);
            border: 1px solid var(--grid-border); cursor: pointer;
        }
        .theme-toggle-icon {
            font-size: 1.1rem; width: 28px; height: 28px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%; transition: background 0.3s; color: var(--text-muted);
        }
        .theme-toggle-icon.active { background: var(--text); color: var(--bg); }

        .game-wrapper {
            display: flex; flex-direction: column;
            height: 100vh; height: 100dvh;
            position: relative; z-index: 1;
        }

        .shake-hard { animation: shake-anim 0.5s cubic-bezier(.36,.07,.19,.97) both; }
        .shake-soft { animation: shake-anim 0.25s cubic-bezier(.36,.07,.19,.97) both; }

        @keyframes shake-anim {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            30%, 70% { transform: translate3d(-4px, 0, 0); }
            50% { transform: translate3d(4px, 0, 0); }
        }

        .hud {
            display: flex; justify-content: center; gap: 20px;
            padding: 10px 16px; background: transparent;
            font-size: 1rem; margin-top: 5px;
            flex-shrink: 0; /* –ó–∞–±–æ—Ä–æ–Ω—è—î–º–æ —Å—Ç–∏—Å–∫–∞—Ç–∏ */
        }
        .hud span { font-weight: 700; color: var(--mikita); text-shadow: 0 0 10px rgba(125, 211, 252, 0.5); }
        body.day-theme .hud span { text-shadow: none; color: #0284c7; }

        .game-field {
            flex: 1; /* –ó–∞–π–º–∞—î –≤–µ—Å—å –≤—ñ–ª—å–Ω–∏–π –ø—Ä–æ—Å—Ç—ñ—Ä */
            display: flex; align-items: center; justify-content: center;
            padding: 5px; overflow: hidden;
            perspective: 1200px;
            min-height: 0; /* –í–∞–∂–ª–∏–≤–æ –¥–ª—è —Ñ–ª–µ–∫—Å—É */
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: repeat(12, 1fr);
            gap: 2px; /* –¢–æ–Ω—à—ñ –ø—Ä–æ–º—ñ–∂–∫–∏ */
            
            /* –õ–æ–≥—ñ–∫–∞ —Ä–æ–∑–º—ñ—Ä—É: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ —à–∏—Ä–∏–Ω–∞ 98% OR –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –≤–∏—Å–æ—Ç–∞ (–≤–∏—Å–æ—Ç–∞ –µ–∫—Ä–∞–Ω—É - 60px –Ω–∞ HUD) */
            /* –ê–ª–µ –Ω–µ —à–∏—Ä—à–µ 800px –¥–ª—è –≤–µ–ª–∏–∫–∏—Ö –µ–∫—Ä–∞–Ω—ñ–≤ */
            width: min(98vw, calc(100vh - 70px), 800px);
            height: min(98vw, calc(100vh - 70px), 800px);
            
            aspect-ratio: 1 / 1; /* –ó–∞–ª–∏—à–∞—î–º–æ –∫–≤–∞–¥—Ä–∞—Ç–Ω–∏–º */
            
            background: var(--grid-bg);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(125, 211, 252, 0.1), 0 15px 30px var(--shadow-color);
            border: 2px solid var(--grid-border);
            transform-style: preserve-3d;
            animation: grid-sway 8s infinite ease-in-out;
            transition: background 0.5s, box-shadow 0.5s;
        }
        
        body.day-theme .grid { box-shadow: 0 5px 20px var(--shadow-color); }

        @keyframes grid-sway {
            0%, 100% { transform: rotate(0deg) rotateX(0deg); }
            25% { transform: rotate(0.3deg) rotateX(0.2deg); }
            75% { transform: rotate(-0.3deg) rotateX(-0.2deg); }
        }

        .cell {
            background: var(--field);
            position: relative;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; border-radius: 2px; overflow: visible;
        }
        .cell:nth-child(even) { background: var(--field-alt); }

        .cell.edge-glow { animation: soft-edge-pulse 6s infinite ease-in-out; }
        body.day-theme .cell.edge-glow { animation: none; }

        @keyframes soft-edge-pulse {
            0%, 100% { background: rgba(255, 255, 255, 0.02); box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.02); }
            50% { background: rgba(255, 255, 255, 0.05); box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.05); }
        }

        .cell:active { background: rgba(255, 255, 255, 0.2) !important; transform: scale(0.9); }

        .cell.path { background: var(--path-color) !important; box-shadow: var(--path-shadow); }
        body.day-theme .cell.path { background: rgba(56, 189, 248, 0.1) !important; }

        .cell.target { background: rgba(251, 191, 36, 0.2) !important; box-shadow: inset 0 0 8px rgba(251, 191, 36, 0.3); animation: target-glow 1s infinite; }
        @keyframes target-glow { 0%, 100% { box-shadow: inset 0 0 8px rgba(251, 191, 36, 0.2); } 50% { box-shadow: inset 0 0 15px rgba(251, 191, 36, 0.4); } }

        .entity {
            position: absolute; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: min(5vw, 2.2rem); /* –ê–¥–∞–ø—Ç–∏–≤–Ω–∏–π —Ä–æ–∑–º—ñ—Ä —à—Ä–∏—Ñ—Ç—É */
            transition: transform 0.15s; pointer-events: none;
        }

        .entity.player {
            filter: drop-shadow(0 0 10px var(--mikita));
            z-index: 15; animation: player-float 1.2s infinite ease-in-out;
            font-size: min(6vw, 2.6rem) !important;
        }
        body.day-theme .entity.player { filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2)); }

        @keyframes player-float { 0%, 100% { transform: translateY(0) scale(1); } 50% { transform: translateY(-2px) scale(1.02); } }

        .entity.npc { z-index: 10; animation: npc-idle 2s infinite ease-in-out; }
        body.day-theme .entity.npc { filter: none; }
        @keyframes npc-idle { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.02); } }

        /* Karina Bow */
        .entity.npc.karina-char::before {
            content: ''; position: absolute; top: 0px; right: 12%;
            width: 10px; height: 7px;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border-radius: 50%; box-shadow: 0 0 4px rgba(239, 68, 68, 0.8); z-index: 20;
        }
        .entity.npc.karina-char::after {
            content: ''; position: absolute; top: 1px; right: 15%;
            width: 4px; height: 4px; background: #991b1b; border-radius: 50%; z-index: 21;
        }

        /* Vadim */
        .entity.npc.vadim-char {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border-radius: 6px; width: 85% !important; height: 85% !important;
            font-size: min(5vw, 2.2rem) !important; font-weight: 700; color: #fff;
            box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
            display: flex; align-items: center; justify-content: center;
        }

        /* Invaders */
        .entity.invader {
            z-index: 12; animation: invader-sway 0.6s infinite ease-in-out;
            filter: drop-shadow(0 0 8px #22c55e) brightness(1.2);
        }
        body.day-theme .entity.invader { filter: none; }
        @keyframes invader-sway { 0%, 100% { transform: rotate(-5deg) scale(1); } 50% { transform: rotate(5deg) scale(1.05); } }

        /* HP Bars */
        .hp-bar-container {
            position: absolute; top: -6px; left: 50%; transform: translateX(-50%);
            width: 24px; height: 4px; background: rgba(0,0,0,0.6);
            border-radius: 2px; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2); z-index: 25;
        }
        .hp-bar-fill { height: 100%; transition: width 0.3s; }
        
        .hp-bar-fill.invader-hp { background: linear-gradient(90deg, #ef4444, #f87171); }
        .hp-bar-fill.invader-hp.mid { background: linear-gradient(90deg, #f97316, #fb923c); }
        .hp-bar-fill.invader-hp.high { background: linear-gradient(90deg, #22c55e, #4ade80); }

        .hp-bar-fill.vadim-hp { background: linear-gradient(90deg, #22c55e, #4ade80); }
        .hp-bar-fill.karina-hp { background: linear-gradient(90deg, #a855f7, #c4b5fd); }
        .hp-bar-fill.katja-hp { background: linear-gradient(90deg, #ec4899, #f472b6); }

        .entity.item { animation: item-float 2s infinite ease-in-out; opacity: 0.4; }
        body.day-theme .entity.item { opacity: 0.6; filter: none; }

        .entity.item.revealed { opacity: 1; filter: drop-shadow(0 0 10px var(--item)); }
        body.day-theme .entity.item.revealed { filter: drop-shadow(0 2px 3px rgba(0,0,0,0.2)); }

        @keyframes item-float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-2px); } }

        .entity.delivering { animation: deliver-burst 0.4s ease-out; }
        @keyframes deliver-burst { 0% { transform: scale(1); } 40% { transform: scale(1.3); filter: brightness(1.5); } 100% { transform: scale(1); } }

        .bubble {
            position: fixed; background: linear-gradient(135deg, #fff, #f0f0f0);
            color: #1a1625; padding: 6px 12px; border-radius: 14px;
            font-size: 0.8rem; white-space: nowrap; z-index: 200;
            pointer-events: none; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-weight: 600; transform: translateX(-50%) scale(0); opacity: 0;
        }
        .bubble::after { content: ''; position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%); border: 5px solid transparent; border-top-color: #f0f0f0; }
        .bubble.show { animation: bubble-pop 2s forwards; }
        @keyframes bubble-pop {
            0% { opacity: 0; transform: translateX(-50%) scale(0) translateY(5px); }
            15% { opacity: 1; transform: translateX(-50%) scale(1.05) translateY(0); }
            85% { opacity: 1; }
            100% { opacity: 0; transform: translateX(-50%) scale(0.9) translateY(-5px); }
        }

        .holding-item {
            position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%);
            background: rgba(30, 24, 48, 0.95);
            padding: 10px 20px; border-radius: 20px; font-size: 1rem;
            display: flex; align-items: center; gap: 10px; z-index: 50;
            border: 2px solid var(--item); box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
        }
        body.day-theme .holding-item { background: rgba(255, 255, 255, 0.95); color: #1e293b; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }
        .holding-item .item-icon { font-size: 1.4rem; animation: item-float 0.8s infinite; }

        .screens {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            display: flex; align-items: center; justify-content: center;
            background: var(--bg-atmo); z-index: 1000; opacity: 0;
            pointer-events: none; transition: opacity 0.4s; padding: 20px;
            backdrop-filter: blur(10px);
        }
        .screens.show { opacity: 1; pointer-events: all; }

        .screen-content { text-align: center; max-width: 400px; width: 100%; }
        .screen-content h1 {
            font-size: 2.8rem; margin-bottom: 10px;
            background: linear-gradient(135deg, #38bdf8, #a78bfa, #f472b6);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        .screen-content .subtitle { color: var(--text-muted); margin-bottom: 20px; font-size: 1.1rem; }
        
        .char-showcase { display: flex; justify-content: center; gap: 15px; margin: 25px 0; flex-wrap: wrap; }
        .char-showcase .char { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .char-showcase .char .avatar {
            width: 60px; height: 60px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-size: 2.2rem;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); position: relative; background: transparent;
        }
        .char-showcase .char span { font-size: 0.9rem; color: var(--text-muted); font-weight: 500; }

        .char-showcase .char:nth-child(1) .avatar { background: linear-gradient(135deg, #22c55e, #16a34a); border-radius: 15px; font-weight: 700; color: #fff; }
        .char-showcase .char:nth-child(2) .avatar { font-size: 3rem; }
        .char-showcase .char:nth-child(3) .avatar { font-size: 3rem; }
        .char-showcase .char:nth-child(3) .avatar::before { content: ''; position: absolute; top: 2px; right: 8px; width: 14px; height: 10px; background: #ef4444; border-radius: 50%; z-index: 20; }
        .char-showcase .char:nth-child(4) .avatar { font-size: 3rem; }

        .instructions { color: var(--text-muted); font-size: 0.95rem; line-height: 1.6; margin: 20px 0; }
        .instructions b { color: var(--text); }
        .disclaimer { font-size: 0.75rem; color: var(--text-muted); margin-top: 20px; font-style: italic; opacity: 0.7; }

        .btn {
            background: linear-gradient(135deg, #38bdf8, #0ea5e9); color: #fff;
            border: none; padding: 14px 35px; font-size: 1.1rem;
            font-family: 'Fredoka', sans-serif; font-weight: 700; border-radius: 25px;
            cursor: pointer; box-shadow: 0 4px 15px rgba(56, 189, 248, 0.3); margin-top: 15px;
        }
        .btn:active { transform: scale(0.95); }

        .game-over h1 { background: linear-gradient(135deg, #f472b6, #ef4444); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .final-stats { margin: 20px 0; font-size: 1rem; }
        .final-stats div { margin: 8px 0; }
        .final-stats span { color: #4ade80; font-weight: 700; }
        body.day-theme .final-stats span { color: #059669; }

        .controls-hint {
            position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
            background: var(--field); padding: 8px 16px; border-radius: 12px;
            font-size: 0.75rem; color: var(--text-muted); z-index: 40;
            text-align: center; border: 1px solid var(--grid-border);
        }

        .plus-effect {
            position: fixed; font-size: 1.2rem; font-weight: bold; color: #4ade80;
            animation: plus-fly 1s forwards; pointer-events: none; z-index: 100;
            text-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        body.day-theme .plus-effect { color: #059669; text-shadow: none; }
        @keyframes plus-fly { 0% { opacity: 1; transform: translateY(0) scale(1); } 100% { opacity: 0; transform: translateY(-40px) scale(1.5); } }
        
        .item-label {
            position: fixed; background: var(--bg); color: var(--text);
            padding: 4px 10px; border-radius: 8px; font-size: 0.85rem; font-weight: 600;
            pointer-events: none; z-index: 150; animation: label-fade 1.5s forwards;
            border: 1px solid var(--grid-border);
        }
        @keyframes label-fade { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-20px); } }

        .hit-text {
            position: fixed; font-weight: 900; color: #ef4444;
            text-shadow: 1px 1px 0 #000;
            animation: hit-pop 0.6s forwards; pointer-events: none; z-index: 200;
        }
        @keyframes hit-pop {
            0% { opacity: 1; transform: scale(0.3) rotate(-10deg); }
            40% { opacity: 1; transform: scale(1.3) rotate(5deg); }
            100% { opacity: 0; transform: scale(1) translateY(-15px) rotate(0deg); }
        }
        .particle { position: fixed; border-radius: 50%; pointer-events: none; z-index: 150; }

        /* –ê–¥–∞–ø—Ç–∏–≤–Ω—ñ—Å—Ç—å –¥–ª—è –¥—É–∂–µ –º–∞–ª–∏—Ö –µ–∫—Ä–∞–Ω—ñ–≤ */
        @media (max-width: 350px) {
            .hud { font-size: 0.9rem; gap: 10px; }
            .grid { width: 98vw; height: 98vw; }
        }
    </style>
</head>
<body>
    <div class="bg-atmosphere">
        <div class="cloud"></div><div class="cloud"></div><div class="cloud"></div>
    </div>

    <div class="theme-toggle" id="theme-toggle" title="–ó–º—ñ–Ω–∏—Ç–∏ —Ç–µ–º—É">
        <div class="theme-toggle-icon" id="icon-sun">‚òÄÔ∏è</div>
        <div class="theme-toggle-icon active" id="icon-moon">üåô</div>
    </div>

    <div class="game-wrapper" id="game-wrapper">
        <div class="hud">
            <div>–•–≤–∏–ª—è: <span id="wave">1</span></div>
            <div>–†–∞—Ö—É–Ω–æ–∫: <span id="score">0</span></div>
        </div>

        <div class="game-field">
            <div class="grid" id="grid"></div>
        </div>

        <div class="holding-item" id="holding" style="display:none">
            –ù–µ—Å—É: <span class="item-icon" id="holding-icon"></span>
        </div>

        <div class="controls-hint">
            –¢–æ—Ä–∫–Ω–∏—Å—å –ø—Ä–µ–¥–º–µ—Ç–∞ –∞–±–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        </div>
    </div>

    <div class="screens" id="start-screen">
        <div class="screen-content">
            <h1>Free4talk game</h1>
            <p class="subtitle">–î–æ–ø–æ–º–æ–∂–∏ –ú—ñ–∫—ñ—Ç—ñ –ø–æ–¥–±–∞—Ç–∏ –ø—Ä–æ –¥—Ä—É–∑—ñ–≤</p>
            <div class="char-showcase">
                <div class="char"><div class="avatar">V</div><span>Vadim</span></div>
                <div class="char"><div class="avatar">ü¶ù</div><span>Mikita</span></div>
                <div class="char"><div class="avatar">üë±‚Äç‚ôÄÔ∏è</div><span>Karina</span></div>
                <div class="char"><div class="avatar">üë©üèª</div><span>Katja</span></div>
            </div>
            <p class="instructions">
                –¢–∏ ‚Äî –ú—ñ–∫—ñ—Ç–∞-–æ–ø–æ—Å—É–º<br><br>
                <b>Vadim</b> —Ö–æ—á–µ –∫–µ–ø–∫—É —ñ —à–∞–º–ø—É–Ω—å<br>
                <b>Karina</b> –≤–∏–≤—á–∞—î –Ω—ñ–º–µ—Ü—å–∫—É ‚Äî —ó–π –ø–æ—Ç—Ä—ñ–±–Ω—ñ –∫–Ω–∏–≥–∞ —Ç–∞ —Ä—É—á–∫–∞<br>
                <b>Katja</b> –º—Ä—ñ—î –ø—Ä–æ –∫–≤—ñ—Ç–∏ —Ç–∞ –∫–≤–∏—Ç–∫–∏ –≤ –∫—ñ–Ω–æ<br><br>
                –ó–∞—Ö–∏—â–∞–π –¥—Ä—É–∑—ñ–≤ –≤—ñ–¥ –º–æ–Ω—Å—Ç—Ä—ñ–≤!
            </p>
            <button class="btn" id="start-btn">–ì–†–ê–¢–ò</button>
            <p class="disclaimer">–ù–µ –æ—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ —Å—é–∂–µ—Ç–∞—Ö –ö–≤–µ–Ω—Ç—ñ–Ω–∞ –¢–∞—Ä–∞–Ω—Ç—ñ–Ω–æ.</p>
        </div>
    </div>

    <div class="screens" id="game-over-screen">
        <div class="screen-content game-over">
            <h1>–ö–Ü–ù–ï–¶–¨ –ì–†–ò</h1>
            <p class="subtitle" id="death-reason">–•—Ç–æ—Å—å –≤—Ç—Ä–∞—Ç–∏–≤ —Å–∏–ª–∏</p>
            <div class="final-stats">
                <div>–†–∞—Ö—É–Ω–æ–∫: <span id="final-score">0</span></div>
                <div>–•–≤–∏–ª—è: <span id="final-wave">1</span></div>
            </div>
            <button class="btn" id="restart-btn">–©–µ —Ä–∞–∑</button>
        </div>
    </div>

    <script>
        const GRID = 12;
        
        const ITEMS = {
            cap: { emoji: 'üß¢', target: 'vadim', name: '–ö–µ–ø–∫–∞', type: 'gift' },
            shampoo: { emoji: 'üß¥', target: 'vadim', name: '–®–∞–º–ø—É–Ω—å', type: 'gift' },
            book: { emoji: 'üìö', target: 'karina', name: '–ö–Ω–∏–≥–∞', type: 'gift' },
            pen: { emoji: 'üñäÔ∏è', target: 'karina', name: '–†—É—á–∫–∞', type: 'gift' },
            flower: { emoji: 'üíê', target: 'katja', name: '–ö–≤—ñ—Ç–∏', type: 'gift' },
            ticket: { emoji: 'üé¨', target: 'katja', name: '–ö–≤–∏—Ç–æ–∫', type: 'gift' },
            boots: { emoji: 'üë¢', target: 'self', name: '–ß–æ–±–æ—Ç–∏', type: 'powerup', effect: 'speed' },
            star: { emoji: '‚≠ê', target: 'self', name: '–ó—ñ—Ä–∫–∞', type: 'powerup', effect: 'score' }
        };
        
        let powerups = { speedBoost: false, speedBoostEnd: 0 };

        const CHARACTERS = { vadim: 'V', mikita: 'ü¶ù', karina: 'üë±‚Äç‚ôÄÔ∏è', katja: 'üë©üèª' };

        const INVADER_TYPES = [
            { emoji: 'üßü', name: 'Zombie', hp: 1 }, { emoji: 'üßü‚Äç‚ôÇÔ∏è', name: 'Zombie', hp: 2 },
            { emoji: 'üëª', name: 'Ghost', hp: 1 }, { emoji: 'üíÄ', name: 'Skeleton', hp: 2 },
            { emoji: 'üëΩ', name: 'Alien', hp: 3 }, { emoji: 'ü§ñ', name: 'Robot', hp: 4 }
        ];

        const DIALOGUES = {
            vadim: {
                happy: ['–û—Ö—É–µ–Ω–Ω–æ!', '–ö–ª–∞—Å!', '–ù–∞—Ä–µ—à—Ç—ñ!', '–ó–æ–ª–æ—Ç–æ!', '–î–∞! –î—è–∫—É—é!', '–ö—Ä–∞—Å–∞–≤–∞!'],
                sad: ['–î–µ –∫–µ–ø–∫–∞...', '–•–æ—á—É —à–∞–º–ø—É–Ω—å...', '–ù—É –≤—Å–µ...', '–ü–∏–∑–¥–µ—Ü—å...'],
                wrong: ['–ù–µ —Ç–µ!', '–ó–∞–±–µ—Ä–∏!', '–ù–∞—Ö–µ—Ä–∞?!', '–ù–µ–∞!'],
                idle: ['–ù—É–¥–Ω–æ...', '–©–æ —Ä–æ–±–∏—Ç–∏?', '–ú—ñ–∫—ñ—Ç–∞!', '–ê—É!', '–ö–µ–ø–∫—É –±...']
            },
            mikita: {
                pickup: ['–ù–µ—Å–µ–º–æ!', '–ó–∞—Ä–∞–∑ –ø—Ä–∏–Ω–µ—Å—É!', '–ó—Ä–æ–∑—É–º—ñ–≤!', '–í–∑—è–≤!'],
                wrong: ['–û–π, –±–ª—ñ–Ω!', '–ù–µ —Ç–æ–º—É!'],
                deliver: {
                    vadim: ['–û—Å—å, –ø–∞–Ω–µ!', '–¢—Ä–∏–º–∞–π—Ç–µ!'],
                    karina: ['–ë—É–¥—å –ª–∞—Å–∫–∞!', '–î–ª—è –≤–∞—Å!'],
                    katja: ['–ë—É–¥—å –ª–∞—Å–∫–∞!', '–î–ª—è –≤–∞—Å!']
                },
                idle: ['–¢–∞ –æ—Å—å –∂–µ!', '–ß–∏–º –±–∏ –∑–∞–π–Ω—è—Ç–∏—Å—å...', '–î–µ —Ç—É—Ç —â–æ...'],
                battle: ['–Ø–¥—Ä–∞–Ω–∞ –º–∞—Ç–∏!', '–°—É—á—ñ –¥—ñ—Ç–∏!', '–û—Ç—Ä–∏–º—É–π!', '–ù–∞ —Ö–∞–ª—è–≤—É!']
            },
            karina: {
                happy: ['Wunderbar!', 'Danke!', 'Sehr gut!', 'Perfekt!', 'Toll!'],
                sad: ['Brauche Buch...', 'Oh je...', 'Hilfe...'],
                wrong: ['Nein!', 'Falsch!'],
                idle: ['Interessant...', 'Muss uben...', 'Wo ist Mikita?']
            },
            katja: {
                happy: ['–î—è–∫—É—é!', '–Ø–∫ –º–∏–ª–æ!', '–ö–≤—ñ—Ç–∏!', '–°—É–ø–µ—Ä!', '–ì–∞—Ä–Ω–æ!'],
                sad: ['–ö–≤—ñ—Ç–∏...', '–ë—É–¥—å –ª–∞—Å–∫–∞...', '–ú–µ–Ω—ñ —Å—É–º–Ω–æ...'],
                wrong: ['–ù–µ –º–µ–Ω—ñ...', '–ù–µ —Ç—Ä–µ–±–∞!'],
                idle: ['–ù—É–¥–Ω–æ...', '–ö–≤—ñ—Ç–∏ –±...', '–ú—ñ–∫—ñ—Ç–∞, –∞—É!']
            }
        };

        let state = {
            player: { x: 6, y: 6 }, targetPos: null,
            npcs: {}, items: [], invaders: [],
            energy: { vadim: 100, mikita: 100, karina: 100, katja: 100 },
            holding: null, score: 0, wave: 1,
            isRunning: false, gameOver: false, moving: false,
            lastDialogue: {}, activeBubbles: []
        };

        let intervals = {};
        let audioCtx = null;

        const themeToggle = document.getElementById('theme-toggle');
        const iconSun = document.getElementById('icon-sun');
        const iconMoon = document.getElementById('icon-moon');

        function setTheme(isDay) {
            if (isDay) {
                document.body.classList.add('day-theme');
                iconSun.classList.add('active');
                iconMoon.classList.remove('active');
            } else {
                document.body.classList.remove('day-theme');
                iconSun.classList.remove('active');
                iconMoon.classList.add('active');
            }
        }

        function initTheme() {
            const hour = new Date().getHours();
            const isDay = hour >= 7 && hour < 20;
            setTheme(isDay);
        }

        themeToggle.addEventListener('click', () => {
            const isDay = !document.body.classList.contains('day-theme');
            setTheme(isDay);
        });

        function initAudio() { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {} }

        function playSound(type) {
            if (!audioCtx) return;
            try {
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                const now = audioCtx.currentTime;
                if (type === 'kick') {
                    osc.type = 'square'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
                    gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now); osc.stop(now + 0.15);
                } else if (type === 'deliver') {
                    osc.frequency.setValueAtTime(400, now); osc.frequency.setValueAtTime(600, now + 0.1); osc.frequency.setValueAtTime(900, now + 0.2);
                    gain.gain.setValueAtTime(0.06, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                } else if (type === 'pickup') {
                    osc.frequency.setValueAtTime(500, now); osc.frequency.exponentialRampToValueAtTime(900, now + 0.1);
                    gain.gain.setValueAtTime(0.06, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'hurt') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                    gain.gain.setValueAtTime(0.08, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now); osc.stop(now + 0.2);
                }
            } catch(e) {}
        }

        function shakeScreen(intense) {
            wrapperEl.classList.add(intense ? 'shake-hard' : 'shake-soft');
            setTimeout(() => wrapperEl.classList.remove('shake-hard', 'shake-soft'), 300);
        }

        function initGrid() {
            gridEl.innerHTML = '';
            for (let y = 0; y < GRID; y++) {
                for (let x = 0; x < GRID; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (x === 0 || x === GRID-1 || y === 0 || y === GRID-1) {
                        if (Math.random() < 0.3) cell.classList.add('edge-glow');
                    }
                    cell.addEventListener('click', () => handleCellClick(x, y));
                    gridEl.appendChild(cell);
                }
            }
        }

        function getCell(x, y) { return (x < 0 || x >= GRID || y < 0 || y >= GRID) ? null : gridEl.children[y * GRID + x]; }

        function getEntity(x, y, exclPlayer = false) {
            if (!exclPlayer && state.player.x === x && state.player.y === y) return { type: 'player', id: 'mikita' };
            for (const [id, npc] of Object.entries(state.npcs)) if (npc.x === x && npc.y === y) return { type: 'npc', id, ...npc };
            for (const item of state.items) if (item.x === x && item.y === y) return { type: 'item', ...item };
            for (const inv of state.invaders) if (inv.x === x && inv.y === y) return { type: 'invader', ...inv };
            return null;
        }

        function render() {
            document.querySelectorAll('.entity, .hp-bar-container').forEach(el => el.remove());

            if (state.targetPos && state.moving) {
                const path = findPath(state.player, state.targetPos);
                path.forEach((pos, i) => { if(i > 0 && i < path.length-1) getCell(pos.x, pos.y)?.classList.add('path'); });
                getCell(state.targetPos.x, state.targetPos.y)?.classList.add('target');
            }

            // Render Invaders
            for (const inv of state.invaders) {
                const cell = getCell(inv.x, inv.y);
                if (cell) {
                    cell.innerHTML += `<div class="entity invader">${inv.emoji}</div>`;
                    const hpP = (inv.hp / inv.maxHp) * 100;
                    let hpClass = hpP > 60 ? 'high' : (hpP > 30 ? 'mid' : '');
                    cell.innerHTML += `<div class="hp-bar-container"><div class="hp-bar-fill invader-hp ${hpClass}" style="width:${hpP}%"></div></div>`;
                }
            }

            // Render Items
            for (const item of state.items) {
                const cell = getCell(item.x, item.y);
                if(cell) cell.innerHTML += `<div class="entity item ${item.revealed ? 'revealed' : ''}">${item.emoji}</div>`;
            }

            // Render NPCs
            for (const [id, npc] of Object.entries(state.npcs)) {
                const cell = getCell(npc.x, npc.y);
                if (cell) {
                    let cls = 'entity npc';
                    if (id === 'karina') cls += ' karina-char';
                    if (id === 'vadim') cls += ' vadim-char';
                    if (state.holding && state.player.x === npc.x && state.player.y === npc.y) cls += ' delivering';
                    cell.innerHTML += `<div class="${cls}">${CHARACTERS[id]}</div>`;
                    cell.innerHTML += `<div class="hp-bar-container"><div class="hp-bar-fill ${id}-hp" style="width:${state.energy[id]}%"></div></div>`;
                }
            }

            // Render Player
            const pCell = getCell(state.player.x, state.player.y);
            if(pCell) pCell.innerHTML += `<div class="entity player">${CHARACTERS.mikita}</div>`;

            updateHUD();
        }

        function updateHUD() {
            document.getElementById('score').textContent = state.score;
            document.getElementById('wave').textContent = state.wave;
            holdingEl.style.display = state.holding ? 'flex' : 'none';
            if(state.holding) document.getElementById('holding-icon').textContent = state.holding.emoji;
        }

        function findPath(start, end, npcWalk = false) {
            const q = [[start]]; const vis = new Set([`${start.x},${start.y}`]);
            while(q.length) {
                const p = q.shift(); const c = p[p.length-1];
                if (c.x === end.x && c.y === end.y) return p;
                for (const [dx, dy] of [[0,1],[0,-1],[1,0],[-1,0]]) {
                    const n = {x: c.x+dx, y: c.y+dy};
                    if (n.x>=0 && n.x<GRID && n.y>=0 && n.y<GRID && !vis.has(`${n.x},${n.y}`)) {
                        const ent = getEntity(n.x, n.y, true);
                        if (!ent || ent.type === 'item') { vis.add(`${n.x},${n.y}`); q.push([...p, n]); }
                        else if (npcWalk && ent.type === 'npc' && n.x===end.x && n.y===end.y) return [...p, n];
                    }
                }
            } return [start];
        }

        function handleCellClick(x, y) {
            if (!state.isRunning || state.gameOver) return;
            const t = getEntity(x, y);
            if (t?.type === 'invader') { kickInvader(t); return; }
            if (t?.type === 'item' && !state.holding) { state.targetPos = {x,y}; state.moving = true; moveToTarget(false); return; }
            if (t?.type === 'npc' && state.holding) { state.targetPos = {x,y}; state.moving = true; moveToTarget(true); return; }
            if (!t) { state.targetPos = {x,y}; state.moving = true; moveToTarget(false); }
        }

        function moveToTarget(npcWalk = false) {
            if (!state.moving || !state.targetPos) return;
            const path = findPath(state.player, state.targetPos, npcWalk);
            if (path.length <= 1) { state.moving = false; state.targetPos = null; checkDelivery(); render(); return; }
            
            const next = path[1];
            const ent = getEntity(next.x, next.y, true);
            if (ent?.type === 'npc' && !npcWalk) { state.moving = false; state.targetPos = null; render(); return; }
            if (ent?.type === 'invader') { state.moving = false; state.targetPos = null; render(); return; }

            state.player.x = next.x; state.player.y = next.y;
            
            const item = state.items.find(i => i.x === next.x && i.y === next.y);
            if (item && !state.holding) { pickupItem(item); state.moving = false; state.targetPos = null; render(); return; }

            if (next.x === state.targetPos.x && next.y === state.targetPos.y) { state.moving = false; state.targetPos = null; checkDelivery(); }
            
            render();
            if (state.moving) setTimeout(() => moveToTarget(npcWalk), powerups.speedBoost && Date.now() < powerups.speedBoostEnd ? 70 : 110);
        }

        function checkDelivery() {
            if (!state.holding) return;
            for (const [id, npc] of Object.entries(state.npcs))
                if (npc.x === state.player.x && npc.y === state.player.y) { deliverItemTo(id); return; }
        }

        function pickupItem(item) {
            if (ITEMS[item.id].type === 'powerup') {
                if (ITEMS[item.id].effect === 'speed') { powerups.speedBoost = true; powerups.speedBoostEnd = Date.now() + 8000; }
                else state.score += 100;
                state.items = state.items.filter(i => i !== item);
                showPlusEffect(ITEMS[item.id].effect === 'speed' ? '–®–í–ò–î–ö–Ü–°–¢–¨!' : '+100');
            } else {
                state.holding = item; state.items = state.items.filter(i => i !== item);
                showDialogue('mikita', 'pickup');
            }
            render();
        }

        function deliverItemTo(npcId) {
            if (!state.holding) return;
            const target = ITEMS[state.holding.id].target;
            if (npcId === target) {
                state.energy[npcId] = Math.min(100, state.energy[npcId] + 25); state.score += 50;
                showDialogue('mikita', 'deliver', npcId, true); setTimeout(() => showDialogue(npcId, 'happy'), 100);
                showPlusEffect('+25');
            } else {
                state.energy[npcId] = Math.max(0, state.energy[npcId] - 15);
                showDialogue(npcId, 'wrong');
            }
            state.holding = null; checkGameOver(); render();
        }

        function showPlusEffect(text) {
            const pCell = getCell(state.player.x, state.player.y); if(!pCell) return;
            const rect = pCell.getBoundingClientRect();
            const el = document.createElement('div'); el.className = 'plus-effect'; el.textContent = text;
            el.style.left = rect.left + rect.width/2 + 'px'; el.style.top = rect.top + 'px';
            document.body.appendChild(el); setTimeout(() => el.remove(), 1000);
        }

        function showDialogue(charId, type, sub = null, high = false) {
            const dials = sub ? DIALOGUES[charId]?.[type]?.[sub] : DIALOGUES[charId]?.[type];
            if (!dials) return;
            const now = Date.now();
            if (state.lastDialogue[charId] && now - state.lastDialogue[charId] < 800) return;
            state.lastDialogue[charId] = now;
            const txt = dials[Math.floor(Math.random() * dials.length)];
            const coords = charId === 'mikita' ? state.player : state.npcs[charId];
            if(!coords) return;
            const cell = getCell(coords.x, coords.y); if(!cell) return;
            const rect = cell.getBoundingClientRect();
            const el = document.createElement('div'); el.className = 'bubble'; el.textContent = txt;
            el.style.left = rect.left + rect.width/2 + 'px'; el.style.top = rect.top - 5 + (high ? -30 : 0) + 'px';
            document.body.appendChild(el);
            requestAnimationFrame(() => el.classList.add('show'));
            setTimeout(() => el.remove(), 2000);
        }

        function kickInvader(inv) {
            const idx = state.invaders.findIndex(i => i.id === inv.id); if(idx===-1) return;
            const m = state.invaders[idx]; m.hp--;
            createKickEffect(m.x, m.y, m.hp <= 0);
            if (Math.random() < 0.5) showDialogue('mikita', 'battle');
            if (m.hp <= 0) { state.invaders.splice(idx, 1); state.score += 10 * m.maxHp; shakeScreen(true); }
            else { state.score += 2; shakeScreen(false); }
            render();
        }

        function createKickEffect(x, y, kill) {
            const cell = getCell(x,y); if(!cell) return;
            const rect = cell.getBoundingClientRect();
            const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
            const txt = document.createElement('div'); txt.className = 'hit-text';
            txt.textContent = kill ? '–ë–£–ú!' : '–ë–ê–•!';
            txt.style.left = cx + 'px'; txt.style.top = cy + 'px';
            document.body.appendChild(txt); setTimeout(() => txt.remove(), 500);
            cell.style.background = 'radial-gradient(#ff6b6b, #ffd93d)';
            setTimeout(() => cell.style.background = '', 100);
        }

        function spawnItem() {
            if (state.items.length >= 4) return;
            const isP = Math.random() < 0.1;
            const types = isP ? ['boots', 'star'] : ['cap', 'shampoo', 'book', 'pen', 'flower', 'ticket'];
            const type = types[Math.floor(Math.random() * types.length)];
            let x, y, att = 0;
            do { x = Math.floor(Math.random()*GRID); y = Math.floor(Math.random()*GRID); att++; } while (getEntity(x,y,true) && att < 30);
            if (att < 30) state.items.push({ id: type, emoji: ITEMS[type].emoji, name: ITEMS[type].name, x, y, revealed: isP || Math.random() > 0.4 });
            render();
        }

        function spawnInvader() {
            if (state.invaders.length >= 2 + state.wave) return;
            const side = Math.floor(Math.random() * 4);
            let x, y;
            if (side===0) { x = Math.floor(Math.random()*GRID); y = 0; }
            else if (side===1) { x = GRID-1; y = Math.floor(Math.random()*GRID); }
            else if (side===2) { x = Math.floor(Math.random()*GRID); y = GRID-1; }
            else { x = 0; y = Math.floor(Math.random()*GRID); }
            const t = INVADER_TYPES[Math.floor(Math.random()*INVADER_TYPES.length)];
            state.invaders.push({ id: Date.now()+Math.random(), emoji: t.emoji, x, y, hp: t.hp, maxHp: t.hp });
            render();
        }

        function moveNPCs() {
            for (const [id, npc] of Object.entries(state.npcs)) {
                if (Math.random() > 0.4) continue;
                const d = [[0,1],[0,-1],[1,0],[-1,0]][Math.floor(Math.random()*4)];
                const nx = npc.x+d[0], ny = npc.y+d[1];
                if (nx>=0 && nx<GRID && ny>=0 && ny<GRID && !getEntity(nx,ny,true)) { npc.x=nx; npc.y=ny; }
            } render();
        }

        function moveInvaders() {
            for (const inv of state.invaders) {
                const npcs = Object.values(state.npcs);
                if (!npcs.length) continue;
                let near = npcs[0], minD = 99;
                npcs.forEach(n => { const d = Math.abs(n.x-inv.x)+Math.abs(n.y-inv.y); if(d<minD){minD=d; near=n;} });
                const dx = Math.sign(near.x - inv.x), dy = Math.sign(near.y - inv.y);
                const moves = []; if(dx!==0) moves.push({x:dx,y:0}); if(dy!==0) moves.push({x:0,y:dy});
                if(!moves.length) continue;
                const mv = moves[Math.floor(Math.random()*moves.length)];
                const nx = inv.x+mv.x, ny = inv.y+mv.y;
                if (nx>=0 && nx<GRID && ny>=0 && ny<GRID) {
                    const t = getEntity(nx,ny);
                    if (t?.type === 'npc') {
                        state.energy[t.id] = Math.max(0, state.energy[t.id] - 12);
                        showDialogue(t.id, 'sad'); shakeScreen(false);
                        if(state.energy[t.id] <= 0) endGame(t.id);
                    } else if (!t) { inv.x=nx; inv.y=ny; }
                }
            } render();
        }

        function randomIdleDialogue() {
            if (Math.random() < 0.3) showDialogue('vadim', 'idle');
            else if (Math.random() < 0.3) showDialogue(['karina','katja','mikita'][Math.floor(Math.random()*3)], 'idle');
        }

        function decayEnergy() {
            for (const c of Object.keys(state.energy)) state.energy[c] = Math.max(0, state.energy[c] - 0.4);
            checkGameOver(); render();
        }

        function checkGameOver() { for (const [c, e] of Object.entries(state.energy)) if (e <= 0) endGame(c); }

        function endGame(dead) {
            state.isRunning = false; state.gameOver = true;
            Object.values(intervals).forEach(clearInterval);
            const names = { vadim: '–í–∞–¥–∏–º', karina: '–ö–∞—Ä–∏–Ω–∞', katja: '–ö–∞—Ç—è' };
            const verb = ['karina','katja'].includes(dead) ? '–≤—Ç—Ä–∞—Ç–∏–ª–∞' : '–≤—Ç—Ä–∞—Ç–∏–≤';
            document.getElementById('death-reason').textContent = `${names[dead]} ${verb} –µ–Ω–µ—Ä–≥—ñ—é!`;
            document.getElementById('final-score').textContent = state.score;
            document.getElementById('final-wave').textContent = state.wave;
            setTimeout(() => gameOverScreen.classList.add('show'), 300);
        }

        function startGame() {
            powerups = {};
            state = {
                player: {x:6,y:6}, targetPos: null,
                npcs: { vadim:{id:'vadim',x:1,y:1}, karina:{id:'karina',x:10,y:1}, katja:{id:'katja',x:1,y:10} },
                items: [], invaders: [],
                energy: { vadim:100, mikita:100, karina:100, katja:100 },
                holding: null, score: 0, wave: 1, isRunning: true, gameOver: false, moving: false, lastDialogue: {}
            };
            startScreen.classList.remove('show'); gameOverScreen.classList.remove('show');
            initGrid(); render();
            
            clearInterval(intervals.decay); clearInterval(intervals.npc); clearInterval(intervals.inv);
            clearInterval(intervals.spI); clearInterval(intervals.spV); clearInterval(intervals.idle);
            
            intervals.decay = setInterval(decayEnergy, 2000);
            intervals.npc = setInterval(moveNPCs, 2500);
            intervals.inv = setInterval(moveInvaders, 1200);
            intervals.spI = setInterval(spawnItem, 4000);
            intervals.spV = setInterval(spawnInvader, 5000);
            intervals.idle = setInterval(randomIdleDialogue, 3000);
            
            spawnItem(); spawnItem();
        }

        const gridEl = document.getElementById('grid');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const holdingEl = document.getElementById('holding');
        const wrapperEl = document.getElementById('game-wrapper');

        document.getElementById('start-btn').addEventListener('click', () => { initAudio(); startGame(); });
        document.getElementById('restart-btn').addEventListener('click', () => { initAudio(); startGame(); });

        initTheme();
        startScreen.classList.add('show');
    </script>
</body>
</html>
