---
layout: post
title: "Befunge: first steps"
description: "Befunge, esoteric language, first steps, simple program"
keywords: ""
category: 
tags: []
---
{% include JB/setup %}

Буду краток. Поковырялся с ужасным эзотерическим языком <a href="http://en.wikipedia.org/wiki/Befunge" title="Befunge on Wiki" target="_blank">Befunge</a>, в итоге разродился простой программкой, выводящей числа от 1 до 10 (да-да, это не так просто сделать, как кажется!).
Фантастика, но __это__ работает.

Программка:
{% highlight php %}
1: v     : <

   5
   2
   *
   `
@  _ :.:1+ ^
{% endhighlight %}

Вывод:
<p class="terminal">
1 2 3 4 5 6 7 8 9 10
</p>

__>updated:__
Теперь перепишем то же самое, но немного усложним - величину, до которой выводить значения, будем запрашивать у юзера. Реализация:
{% highlight php %}
&11p  1: v   :   <
         1
         1
         g
         
         `       
      @  _ :.:1+ ^ 
{% endhighlight %}

Вывод:
<p class="terminal">
Befunge-93 Interpreter/Debugger v2.23
20
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
</p>

Т.е запросили выводить до 20; вывод корректный.

Теперь затрону такую офигенную фишку Befunge как возможность самомодификации, которая встроена в сам язык(!). Это реализуется командами __p__ и __g__.
Первая пушит в код программы по указанным на стеке координатам x и y ASCII значение (пример использования: "101p" - пишет ASCII символ, соответствующий единице по координатам x=0, y=1.).
Вторая инструкция получает значение по координатам и пушит его на вершину стека.

А вот простенький пример самомодификации на Befunge:
{% highlight php %}
52*5*80p1.@
{% endhighlight %}

Несмотря на то что в коде явно прописано вывести на экран 1, выведется 50. Разберем подробнее:

Сначала на стек ложится 5 и 2. Берутся эти числа, перемножаются, и результат ложится на вершину стека. Имеем 10.


На вершину стека ложится 5. Далее опять перемножение (уже 10 и 5), что дает 50; результат опять ложится на вершину стека. Имеем 50.


Далее на стек ложатся последовательно 8 и затем 0. Имеем 50, 8, 0.


Далее команда __p__ пишет ASCII значение 50 (т.е двойку) на место инструкции с координатами (0,8) затирая собой находящуюся там единичку:)


Далее значение лежащее на стеке выводится на экран и программа завершает свою работу. В итоге выводится 2, а не 1!



Начало положено, далее что-нибудь еще напишу в свободное время.
